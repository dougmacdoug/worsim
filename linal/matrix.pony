type M2 is (V2, V2)
""" tuple based matrix aliases"""
type M3 is (V3, V3, V3)
type M4 is (V4, V4, V4, V4)
""" tuple based quaternion alias"""

primitive M2fun
  fun apply(r1: V2, r2: V2) : M2 => (r1, r2)
  fun zero() : M2 => ((0,0),(0,0))
  fun id() : M2 => ((1,0),(0,1))
  fun rowx(m: M2) : V2 => m._1
  fun rowy(m: M2) : V2 => m._2
  fun colx(m: M2) : V2 => (m._1._1, m._2._1)
  fun coly(m: M2) : V2 => (m._1._2, m._2._2)
  fun rot(angle: F32) : M2 =>
      let c : F32 = angle.cos()
      let s : F32 = angle.sin()
      ((c, -s), (s, c))
  fun add(a: M2, b: M2) : M2  =>
     ( (a._1._1 + b._1._1, a._1._2 + b._1._2),
       (a._2._1 + b._2._1, a._2._2 + b._2._2) )

  fun sub(a: M2, b: M2) : M2 =>
    ( (a._1._1 - b._1._1, a._1._2 - b._1._2),
      (a._2._1 - b._2._1, a._2._2 - b._2._2) )

  fun neg(a: M2) : M2 =>((-a._1._1, -a._1._2), (-a._2._1, -a._2._2))

  fun mul(a: M2, s: F32) : M2 =>
    ((a._1._1*s, a._1._2*s), (a._2._1*s, a._2._2*s))

  fun div(a: M2, s: F32) : M2 => mul(a, F32(1) / s)

  fun trans(a: M2) : M2 => ((a._1._1, a._2._1), (a._1._2, a._2._2))

  fun mulv2(a: M2, v: V2) : V2 =>
      ( (a._1._1*v._1) + (a._1._2* v._2), (a._2._1*v._1) + (a._2._2*v._2))

  fun mulm2(a: M2, b: M2) : M2 =>
    ( ((a._1._1 * b._1._1) + (a._1._2 * b._2._1),
      (a._1._1 * b._1._2) + (a._1._2 * b._2._2)),
      ((a._2._1 * b._1._1) + (a._2._2 * b._2._1),
      (a._2._1 * b._1._2) + (a._2._2 * b._2._2)) )

   fun trace(m: M2) : F32 => m._1._1 + m._2._2

   fun det(m: M2) : F32 => (m._1._1 * m._2._2) - (m._1._2 * m._2._1)

   fun inv(m: M2) : M2 =>
      let m2 = ((m._2._2, -m._1._2), (-m._2._1, m._1._1))
      div(m2, det(m))

   fun solve(m: M2, v: V2) : V2 =>
     ( (((m._1._2 * v._2) - (m._2._2 * v._1)) / ((m._1._2*m._2._1) - (m._1._1*m._2._2))),
      (((m._2._1 * v._1) - (m._1._1 * v._2)) / ((m._1._2*m._2._1) - (m._1._1*m._2._2))))

   fun eq(a: M2, b: M2, eps: F32 = F32.epsilon()) : Bool =>
     Linear.eq(a._1._1, b._1._1, eps) and
     Linear.eq(a._1._2, b._1._2, eps) and
     Linear.eq(a._2._1, b._2._1, eps) and
     Linear.eq(a._2._2, b._2._2, eps)

primitive M3fun
  fun apply(r1: V3, r2: V3, r3: V3) : M3 => (r1, r2, r3)
  fun zero() : M3 => ((0,0,0),(0,0,0),(0,0,0))
  fun id() : M3 => ((1,0,0),(0,1,0),(0,0,1))
  fun rowx(m: M3) : V3 => m._1
  fun rowy(m: M3) : V3 => m._2
  fun rowz(m: M3) : V3 => m._3
  fun colx(m: M3) : V3 => (m._1._1, m._2._1, m._3._1)
  fun coly(m: M3) : V3 => (m._1._2, m._2._2, m._3._2)
  fun colz(m: M3) : V3 => (m._1._3, m._2._3, m._3._3)

  fun rotx(angle: F32) : M3 =>
    let c : F32 = angle.cos()
    let s : F32 = angle.sin()
    ((1, 0, 0), (0, c, -s), (0, s, c))
  fun roty(angle: F32) : M3 =>
    let c : F32 = angle.cos()
    let s : F32 = angle.sin()
    ((c, 0, s), (0, 1, 0), (-s, 0, c))
  fun rotz(angle: F32) : M3 =>
    let c : F32 = angle.cos()
    let s : F32 = angle.sin()
    ((c, -s, 0), (s, c, 0), (0, 0, 1))

   fun add(a: M3, b: M3) : M3 =>
      ( (a._1._1 + b._1._1, a._1._2 + b._1._2, a._1._3 + b._1._3),
        (a._2._1 + b._2._1, a._2._2 + b._2._2, a._2._3 + b._2._3),
        (a._3._1 + b._3._1, a._3._2 + b._3._2, a._3._3 + b._3._3))

   fun sub(a: M3, b: M3)  : M3 =>
     ( (a._1._1 - b._1._1, a._1._2 - b._1._2, a._1._3 - b._1._3),
       (a._2._1 - b._2._1, a._2._2 - b._2._2, a._2._3 - b._2._3),
       (a._3._1 - b._3._1, a._3._2 - b._3._2, a._3._3 - b._3._3))

   fun neg(a: M3) : M3 =>
     ( (-a._1._1, -a._1._2, -a._1._3),
       (-a._2._1, -a._2._2, -a._2._3),
       (-a._3._1, -a._3._2, -a._3._3) )

   fun mul(a: M3, s: F32) : M3 =>
     ( (a._1._1*s, a._1._2*s, a._1._3*s),
       (a._2._1*s, a._2._2*s, a._2._3*s),
       (a._3._1*s, a._3._2*s, a._3._3*s) )

   fun div(a: M3, s: F32) : M3 => mul(a, F32(1)/s)

   fun trans(a: M3) : M3 =>
      ((a._1._1, a._2._1, a._3._1),
       (a._1._2, a._2._2, a._3._2),
       (a._1._3, a._2._3, a._3._3))

   fun mulv3(a: M3, v: V3) : V3 =>
       ((a._1._1 * v._1) + (a._1._2 * v._2) + (a._1._3 * v._3),
        (a._2._1 * v._1) + (a._2._2 * v._2) + (a._2._3 * v._3),
        (a._3._1 * v._1) + (a._3._2 * v._2) + (a._3._3 * v._3))

   fun mulm3(a: M3, b: M3) : M3 =>
     (((a._1._1 * b._1._1) + (a._1._2 * b._2._1) + (a._1._3 * b._3._1),
       (a._1._1 * b._1._2) + (a._1._2 * b._2._2) + (a._1._3 * b._3._2),
       (a._1._1 * b._1._3) + (a._1._2 * b._2._3) + (a._1._3 * b._3._3)),
      ((a._2._1 * b._1._1) + (a._2._2 * b._2._1) + (a._2._3 * b._3._1),
       (a._2._1 * b._1._2) + (a._2._2 * b._2._2) + (a._2._3 * b._3._2),
       (a._2._1 * b._1._3) + (a._2._2 * b._2._3) + (a._2._3 * b._3._3)),
      ((a._3._1 * b._1._1) + (a._3._2 * b._2._1) + (a._3._3 * b._3._1),
       (a._3._1 * b._1._2) + (a._3._2 * b._2._2) + (a._3._3 * b._3._2),
       (a._3._1 * b._1._3) + (a._3._2 * b._2._3) + (a._3._3 * b._3._3)))

    fun trace(m: M3) : F32 => m._1._1 + m._2._2 + m._3._3

    fun det(m: M3) : F32 =>
       (m._1._1 * m._2._2 * m._3._3) +
       (m._1._2 * m._2._3 * m._3._1) +
      ((m._2._1 * m._3._2 * m._1._3) -
       (m._1._3 * m._2._2 * m._3._1) -
       (m._1._1 * m._2._3 * m._3._2) -
       (m._1._2 * m._2._1 * m._3._3))

    fun inv(m: M3) : M3 =>
      let d =  det(m)
      if d == 0 then zero() else
      ((((m._2._2 * m._3._3) - (m._2._3 * m._3._2)) / d,
        ((m._3._2 * m._1._3) - (m._3._3 * m._1._2)) / d,
        ((m._1._2 * m._2._3) - (m._1._3 * m._2._2)) / d),
       (((m._2._3 * m._3._1) - (m._2._1 * m._3._3)) / d,
        ((m._3._3 * m._1._1) - (m._3._1 * m._1._3)) / d,
        ((m._1._3 * m._2._1) - (m._1._1 * m._2._3)) / d),
       (((m._2._1 * m._3._2) - (m._2._2 * m._3._1)) / d,
        ((m._3._1 * m._1._2) - (m._3._2 * m._1._1)) / d,
        ((m._1._1 * m._2._2) - (m._1._2 * m._2._1)) / d))
      end

    fun solve(m: M3, v: V3) : V3 =>
      let d  = det(m)
      let dx = det(((v._1,m._1._2,m._1._3),(v._2,m._2._2,m._2._3),(v._3,m._3._2,m._3._3)))
      let dy = det(((m._1._1,v._1,m._1._3),(m._2._1,v._2,m._2._3),(m._3._1,v._3,m._3._3)))
      let dz = det(((m._1._1,m._1._2,v._1),(m._2._1,m._2._2,v._2),(m._3._1,m._3._2,v._3)))
      (dx/d, dy/d, dz/d)

    fun eq(a: M3, b: M3, eps: F32 = F32.epsilon()) : Bool =>
      Linear.eq(a._1._1, b._1._1, eps) and
      Linear.eq(a._1._2, b._1._2, eps) and
      Linear.eq(a._1._3, b._1._3, eps) and
      Linear.eq(a._2._1, b._2._1, eps) and
      Linear.eq(a._2._2, b._2._2, eps) and
      Linear.eq(a._2._3, b._2._3, eps) and
      Linear.eq(a._3._1, b._3._1, eps) and
      Linear.eq(a._3._2, b._3._2, eps) and
      Linear.eq(a._3._3, b._3._3, eps)

primitive M4fun
  fun apply(r1: V4, r2: V4, r3: V4, r4: V4) : M4 => (r1, r2, r3, r4)
  fun zero() : M4 => ((0,0,0,0),(0,0,0,0),(0,0,0,0),(0,0,0,0))
  fun id() : M4 => ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1))
  fun rowx(m: M4) : V4 => m._1
  fun rowy(m: M4) : V4 => m._2
  fun rowz(m: M4) : V4 => m._3
  fun roww(m: M4) : V4 => m._4
  fun colx(m: M4) : V4 => (m._1._1, m._2._1, m._3._1, m._4._1)
  fun coly(m: M4) : V4 => (m._1._2, m._2._2, m._3._2, m._4._2)
  fun colz(m: M4) : V4 => (m._1._3, m._2._3, m._3._3, m._4._3)
  fun colw(m: M4) : V4 => (m._1._4, m._2._4, m._3._4, m._4._4)
  fun row(m: M4, 0) : V4 => m._1
  fun row(m: M4, 1) : V4 => m._2
  fun row(m: M4, 2) : V4 => m._3
  fun row(m: M4, 3) : V4 => m._4
  fun row(m: M4, n : USize) ? => error

  // fun rotx(angle: F32) : M4 =>
  //   let c : F32 = angle.cos()
  //   let s : F32 = angle.sin()
  //   ((1, 0, 0), (0, c, -s), (0, s, c))
  // fun roty(angle: F32) : M3 =>
  //   let c : F32 = angle.cos()
  //   let s : F32 = angle.sin()
  //   ((c, 0, s), (0, 1, 0), (-s, 0, c))
  // fun rotz(angle: F32) : M3 =>
  //   let c : F32 = angle.cos()
  //   let s : F32 = angle.sin()
  //   ((c, -s, 0), (s, c, 0), (0, 0, 1))

   fun add(a: M4, b: M4) : M4 =>
      ( (a._1._1 + b._1._1,  a._1._2 + b._1._2,
                   a._1._3 + b._1._3,  a._1._4 + b._1._4),
        (a._2._1 + b._2._1,  a._2._2 + b._2._2,
                   a._2._3 + b._2._3,  a._2._4 + b._2._4),
        (a._3._1 + b._3._1,  a._3._2 + b._3._2,
                   a._3._3 + b._3._3,  a._3._4 + b._3._4),
        (a._4._1 + b._4._1,  a._4._2 + b._4._2,
                   a._4._3 + b._4._3,  a._4._4 + b._4._4))

   fun sub(a: M4, b: M4) : M4 =>
      ( (a._1._1 - b._1._1,  a._1._2 - b._1._2,
                   a._1._3 - b._1._3,  a._1._4 - b._1._4),
        (a._2._1 - b._2._1,  a._2._2 - b._2._2,
                   a._2._3 - b._2._3,  a._2._4 - b._2._4),
        (a._3._1 - b._3._1,  a._3._2 - b._3._2,
                   a._3._3 - b._3._3,  a._3._4 - b._3._4),
        (a._4._1 - b._4._1,  a._4._2 - b._4._2,
                   a._4._3 - b._4._3,  a._4._4 - b._4._4))

   fun neg(a: M4) : M4 =>
     ( (-a._1._1, -a._1._2, -a._1._3, -a._1._4),
       (-a._2._1, -a._2._2, -a._2._3, -a._2._4),
       (-a._3._1, -a._3._2, -a._3._3, -a._3._4),
       (-a._4._1, -a._4._2, -a._4._3, -a._4._4) )

   fun mul(a: M4, s: F32) : M4 =>
     ( (a._1._1*s, a._1._2*s, a._1._3*s, a._1._4*s),
       (a._2._1*s, a._2._2*s, a._2._3*s, a._2._4*s),
       (a._3._1*s, a._3._2*s, a._3._3*s, a._3._4*s),
       (a._4._1*s, a._4._2*s, a._4._3*s, a._4._4*s) )

   fun div(a: M4, s: F32) : M4 => mul(a, F32(1)/s)

   // fun trans(a: M3) : M3 =>
   //    ((a._1._1, a._2._1, a._3._1),
   //     (a._1._2, a._2._2, a._3._2),
   //     (a._1._3, a._2._3, a._3._3))

   // fun mulv3(a: M3, v: V3) : V3 =>
   //     ((a._1._1 * v._1) + (a._1._2 * v._2) + (a._1._3 * v._3),
   //      (a._2._1 * v._1) + (a._2._2 * v._2) + (a._2._3 * v._3),
   //      (a._3._1 * v._1) + (a._3._2 * v._2) + (a._3._3 * v._3))

   // fun mulm3(a: M3, b: M3) : M3 =>
   //   (((a._1._1 * b._1._1) + (a._1._2 * b._2._1) + (a._1._3 * b._3._1),
   //     (a._1._1 * b._1._2) + (a._1._2 * b._2._2) + (a._1._3 * b._3._2),
   //     (a._1._1 * b._1._3) + (a._1._2 * b._2._3) + (a._1._3 * b._3._3)),
   //    ((a._2._1 * b._1._1) + (a._2._2 * b._2._1) + (a._2._3 * b._3._1),
   //     (a._2._1 * b._1._2) + (a._2._2 * b._2._2) + (a._2._3 * b._3._2),
   //     (a._2._1 * b._1._3) + (a._2._2 * b._2._3) + (a._2._3 * b._3._3)),
   //    ((a._3._1 * b._1._1) + (a._3._2 * b._2._1) + (a._3._3 * b._3._1),
   //     (a._3._1 * b._1._2) + (a._3._2 * b._2._2) + (a._3._3 * b._3._2),
   //     (a._3._1 * b._1._3) + (a._3._2 * b._2._3) + (a._3._3 * b._3._3)))

   //  fun trace(m: M3) : F32 => m._1._1 + m._2._2 + m._3._3

   //  fun det(m: M3) : F32 =>
   //     (m._1._1 * m._2._2 * m._3._3) +
   //     (m._1._2 * m._2._3 * m._3._1) +
   //    ((m._2._1 * m._3._2 * m._1._3) -
   //     (m._1._3 * m._2._2 * m._3._1) -
   //     (m._1._1 * m._2._3 * m._3._2) -
   //     (m._1._2 * m._2._1 * m._3._3))

   //  fun inv(m: M3) : M3 =>
   //    let d =  det(m)
   //    if d == 0 then zero() else
   //    ((((m._2._2 * m._3._3) - (m._2._3 * m._3._2)) / d,
   //      ((m._3._2 * m._1._3) - (m._3._3 * m._1._2)) / d,
   //      ((m._1._2 * m._2._3) - (m._1._3 * m._2._2)) / d),
   //     (((m._2._3 * m._3._1) - (m._2._1 * m._3._3)) / d,
   //      ((m._3._3 * m._1._1) - (m._3._1 * m._1._3)) / d,
   //      ((m._1._3 * m._2._1) - (m._1._1 * m._2._3)) / d),
   //     (((m._2._1 * m._3._2) - (m._2._2 * m._3._1)) / d,
   //      ((m._3._1 * m._1._2) - (m._3._2 * m._1._1)) / d,
   //      ((m._1._1 * m._2._2) - (m._1._2 * m._2._1)) / d))
   //    end

   //  fun solve(m: M3, v: V3) : V3 =>
   //    let d  = det(m)
   //    let dx = det(((v._1,m._1._2,m._1._3),(v._2,m._2._2,m._2._3),(v._3,m._3._2,m._3._3)))
   //    let dy = det(((m._1._1,v._1,m._1._3),(m._2._1,v._2,m._2._3),(m._3._1,v._3,m._3._3)))
   //    let dz = det(((m._1._1,m._1._2,v._1),(m._2._1,m._2._2,v._2),(m._3._1,m._3._2,v._3)))
   //    (dx/d, dy/d, dz/d)

   //  fun eq(a: M3, b: M3, eps: F32 = F32.epsilon()) : Bool =>
   //    Linear.eq(a._1._1, b._1._1, eps) and
   //    Linear.eq(a._1._2, b._1._2, eps) and
   //    Linear.eq(a._1._3, b._1._3, eps) and
   //    Linear.eq(a._2._1, b._2._1, eps) and
   //    Linear.eq(a._2._2, b._2._2, eps) and
   //    Linear.eq(a._2._3, b._2._3, eps) and
   //    Linear.eq(a._3._1, b._3._1, eps) and
   //    Linear.eq(a._3._2, b._3._2, eps) and
   //    Linear.eq(a._3._3, b._3._3, eps)
